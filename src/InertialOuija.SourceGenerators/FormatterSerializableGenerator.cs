using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace InertialOuija.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class FormatterSerializableGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(static ctx =>
		{
			//ctx.AddEmbeddedAttributeDefinition();
			ctx.AddSource("Attributes.g.cs", SourceText.From(Attribute, Encoding.UTF8));
		});

		context.RegisterSourceOutput(
			context.SyntaxProvider.ForAttributeWithMetadataName(
				$"{AttributesNamespace}.{MarkerAttributeName}",
				static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax or StructDeclarationSyntax,
				static (context, _) => BuildTargetTypeInfo(context)
			)
			.Where(static target => target is not null),
			static (context, source) => Execute(context, source!.Value)
		);
	}

	private static TargetType? BuildTargetTypeInfo(GeneratorAttributeSyntaxContext context)
	{
		if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
			throw new NotSupportedException("Unsupported kind of type");

		if (classSymbol.ContainingType is not null)
			throw new NotSupportedException("Nested types are not supported");

		var targetProperties = ImmutableArray.CreateBuilder<TargetMember>();
		var externAliases = new HashSet<string>();

		var members = classSymbol.GetMembers();
		foreach (var member in members)
		{
			if (member.IsStatic)
				continue;
			else if (member is IPropertySymbol { IsWriteOnly: false } prop && (!prop.IsReadOnly || IsAutoProperty(prop)) && !IsNonSerialized(prop))
				AddMember(prop, prop.Type, prop.IsRequired);
			else if (member is IFieldSymbol field && !IsBackingField(field) && !IsNonSerialized(field))
				AddMember(field, field.Type, field.IsRequired);
		}

		if (targetProperties.Count == 0)
			return null;

		return new TargetType(
			classSymbol.Name,
			classSymbol.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)),
			externAliases.ToImmutableArray(),
			targetProperties.DrainToImmutable()
		);

		void AddMember(ISymbol symbol, ITypeSymbol type, bool required)
		{
			if (type is not INamedTypeSymbol namedType)
				throw new NotSupportedException($"Unsupported type {type}"); // arrays, generic type parameters, pointers

			var underlyingNullableType = GetUnderlyingNullableType(namedType);
			targetProperties.Add(new(
				symbol.Name,
				GetActualTypeName(underlyingNullableType ?? namedType),
				underlyingNullableType is not null,
				required
			));
		}

		INamedTypeSymbol? GetUnderlyingNullableType(INamedTypeSymbol type) =>
			type.IsValueType && type.NullableAnnotation == NullableAnnotation.Annotated ? (INamedTypeSymbol)type.TypeArguments.Single() : null;

		bool IsAutoProperty(IPropertySymbol property) =>
			property is { IsWriteOnly: false } && members.Any(member => member is IFieldSymbol field && SymbolEqualityComparer.Default.Equals(field.AssociatedSymbol, property));

		bool IsBackingField(IFieldSymbol field) => field.AssociatedSymbol is IPropertySymbol;

		// This should check the namespace to be sure, but who really cares
		bool IsNonSerialized(ISymbol member) => member.GetAttributes().Any(attr =>
			attr.AttributeClass is { Name: nameof(NonSerializedAttribute) or NonSerializableAttributeName } attrType);

		string GetActualTypeName(INamedTypeSymbol type)
		{
			var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

			// Surely there's a better/intended way to do this?
			if (type.SpecialType is SpecialType.None &&
				context.SemanticModel.Compilation.GetMetadataReference(type.ContainingAssembly) is { Properties.Aliases.IsEmpty: false } metaRef)
			{
				var alias = metaRef.Properties.Aliases.First();
				externAliases.Add(alias);
				name = name.Replace("global::", $"{alias}::");
			}
			return name;
		}
	}

	private static void Execute(SourceProductionContext context, TargetType target)
	{
		bool hasRequiredProperties = target.Properties.Any(prop => prop.IsRequired);

		using var src = new CodeWriter();

		src.WriteLine("// <auto-generated />");

		foreach (var alias in target.ExternAliases)
			src.WriteLine($"extern alias {alias};");

		src.WriteLine("using global::System.Runtime.Serialization;")
		   .WriteLine();

		if (target.Namespace is not null)
			src.WriteLine($"namespace {target.Namespace};").WriteLine();

		src.WriteLine($"partial class {target.Name}").OpenBrace();

		// ctor
		src.WriteLine($"[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]", target.Properties.Any(prop => prop.IsRequired));
		src.WriteLine($"internal {target.Name}(SerializationInfo info, StreamingContext context)").OpenBrace();
		foreach (var prop in target.Properties)
		{
			if (!prop.IsRequired)
				continue;
			var thisName = GetThisPrefixedName(prop.Name);
			if (!prop.IsNullableValueType && GetValueMethods.TryGetValue(prop.Type, out var methodName))
				src.WriteLine($"{thisName} = info.Get{methodName}(nameof({thisName}));");
			else
				src.WriteLine($"{thisName} = ({prop.NullableType})info.GetValue(nameof({thisName}), typeof({prop.Type}));"); // leaving out the ? on the typeof is intentional
		}
		src.WriteLine("foreach (var entry in info)").OpenBrace();
		src.WriteLine("switch (entry.Name)").OpenBrace();
		foreach (var prop in target.Properties)
		{
			if (prop.IsRequired)
				continue;
			var thisName = GetThisPrefixedName(prop.Name);
			src.WriteLine($"case nameof({thisName}):")
			   .Indent()
			   .WriteLine($"{thisName} = ({prop.NullableType})entry.Value;")
			   .WriteLine("break;")
			   .Unindent();
		}
		src.CloseBrace(); // switch
		src.CloseBrace(); // foreach
		src.CloseBrace(); // ctor

		src.WriteLine();

		// GetObjectData
		src.WriteLine("void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)").OpenBrace();
		foreach (var prop in target.Properties)
		{
			var thisName = GetThisPrefixedName(prop.Name);
			src.WriteLine($"info.AddValue(nameof({thisName}), {thisName});");
		}
		src.CloseBrace(); // GetObjectData

		src.CloseBrace(); // class

		// Needs a better way to generate unique, filesystem-safe names for general use
		context.AddSource($"{target.Name}.g.cs", src.ToSourceText());

		static string GetThisPrefixedName(string propertyName) => propertyName is "info" or "context" or "entry" ? $"this.{propertyName}" : propertyName;
	}


	private const string AttributesNamespace = "InertialOuija.SourceGenerators";
	private const string MarkerAttributeName = "ImplementISerializableAttribute";
	private const string NonSerializableAttributeName = "NonSerializedPropertyAttribute";
	private static string Attribute => $$"""		
		// <auto-generated />
		namespace {{AttributesNamespace}}
		{
			[global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
			internal class {{MarkerAttributeName}} : System.Attribute
			{ }
			[global::System.AttributeUsage(global::System.AttributeTargets.Property)]
			internal class {{NonSerializableAttributeName}} : System.Attribute
			{ }
		}
		""";

	private static readonly Dictionary<string, string> GetValueMethods = new()
	{
		["bool"] = "Boolean",
		["char"] = "Char",
		["sbyte"] = "SByte",
		["short"] = "Int16",
		["int"] = "Int32",
		["long"] = "Int64",
		["byte"] = "Byte",
		["ushort"] = "UInt16",
		["uint"] = "UInt32",
		["ulong"] = "UInt64",
		["float"] = "Single",
		["double"] = "Double",
		["decimal"] = "Decimal",
		["string"] = "String",
		["global::System.DateTime"] = "DateTime",
	};


	private record struct TargetType(string Name, string? Namespace, ValueEquatableArray<string> ExternAliases, ValueEquatableArray<TargetMember> Properties);

	private record struct TargetMember(string Name, string Type, bool IsNullableValueType, bool IsRequired)
	{
		public readonly string NullableType => Type + (IsNullableValueType ? "?" : "");
	}
}
